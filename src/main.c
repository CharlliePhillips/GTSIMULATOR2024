#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
#include "images/garbage.h"
#include "images/buzzL.h"
#include "images/buzzR.h"
#include "images/background.h"
#include "images/historyBook.h"
#include "images/oldSpice.h"
#include "images/pictureOfMonkEB.h"
#include "images/pictureOfMonkEO.h"
#include "images/gtsimTitle.h"
#include "images/leaderboard.h"
#include "images/pointer.h"
#include "images/t.h"
#include "images/pizzaL.h"
#include "images/pizzaR.h"
#include "images/playerSelectScreen.h"
#include "images/win.h"
/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  WIN,
  LOSE,
  LEADERBOARD,
  PLAYER_SELECT
};

//player data
static u16 playerX = WIDTH / 2;
static u16 playerY = 80;
static short playerVX = 1;
static short playerVY = 0;

char *playString = "Play";
char *leaderboardString = "Leaderboard";
const u16 *playerImg;
const u16 *playerImgL;
const u16 *playerImgR;

int selectedPlayer = 1;


u16 player0BestTime = 0;
u16 player1BestTime = 0;
u16 player2BestTime = 0;

u16 currPlayerTime = 0;

int main(void) {
  
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;
  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;
  int nextState = (int) START;

  //initilize enemies

      enemy e1 = {
        .X = 25,
        .Y = HEIGHT / 2,
        .VX = 1,
        .VY = 1,
        .width = GARBAGE_WIDTH,
        .height = GARBAGE_HEIGHT,
        .img = &garbage[0]
      };

      enemy e2 = {
        .X = WIDTH / 2,
        .Y = 25,
        .VX = 1,
        .VY = 1,
        .width = HISTORYBOOK_WIDTH,
        .height = HISTORYBOOK_HEIGHT,
        .img = &historyBook[0]
      };

      enemy e3 = {
        .X = WIDTH / 2 - 50,
        .Y = HEIGHT / 2 - 50,
        .VX = -1,
        .VY = -1,
        .width = OLDSPICE_WIDTH,
        .height = OLDSPICE_HEIGHT,
        .img = &oldSpice[0]
      };
        enemy *uga = &e1;
        enemy *book = &e2;
        enemy *deoderant = &e3;

        enemy *enemies[] = {uga, book, deoderant,NULL};

  

  // Load initial application state
  enum gba_state state = (enum gba_state) nextState;

  drawFullScreenImageDMA(&gtsimTitle[0]);
  drawString(HEIGHT / 2 + 15, 85, playString, BLACK);
  drawString(HEIGHT /2 + 30, 85, leaderboardString, BLACK);
  drawImageDMA(HEIGHT / 2 + 13, 70, POINTER_WIDTH, POINTER_HEIGHT, &pointer[0]);

  int selectedItem = 0;

  int instrX = 15;
  int instrVX = 1;
  char *instr = "press A or Start...";
  
  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons
          /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw
    if(KEY_DOWN(BUTTON_SELECT, currentButtons)) {
      drawTitleScreen();
      state = START;
    }
    switch (state) {
      case START:
        
        e1.X = 25;
        e1.Y = HEIGHT / 2;
        e1.VX = 1;
        e1.VY = 1;

        e2.X = WIDTH / 2;
        e2.Y = 25;
        e2.VX = 1;
        e2.VY = 1;

        e3.X = WIDTH / 2 - 50;
        e3.Y = HEIGHT / 2 - 50;
        e3.VX = -1;
        e3.VY = -1;

        playerX = WIDTH / 2 ;
        playerY = 100;
        currPlayerTime = 0;

        waitForVBlank();
        undrawImageDMA(140, instrX, WIDTH, 10, gtsimTitle);
        if ((instrX < (125)) & (instrX > 0)) {
          instrX += instrVX;
        } else {
          instrVX *= -1;
          instrX += instrVX;
        }
        drawString(140, instrX, instr, BLUE);
        // state = ?
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons) | KEY_JUST_PRESSED(BUTTON_A, currentButtons, previousButtons)) {
          if (selectedItem == 0) {
            drawFullScreenImageDMA(playerSelectScreen);
            drawPSelectBox(selectedPlayer);
            state = PLAYER_SELECT;
          }
          if (selectedItem == 1) {
            state = LEADERBOARD;
            drawFullScreenImageDMA(leaderboard);
            drawScores();
            selectedItem = 0;

          }
        }

        if (KEY_JUST_PRESSED(BUTTON_DOWN, currentButtons, previousButtons) | KEY_JUST_PRESSED(BUTTON_UP, currentButtons, previousButtons)) {
          if (selectedItem == 0) {
            undrawImageDMA(HEIGHT / 2 + 13, 70, POINTER_WIDTH, POINTER_HEIGHT, &gtsimTitle[0]);
            selectedItem = 1;
            drawImageDMA(HEIGHT / 2 + 28, 70, POINTER_WIDTH, POINTER_HEIGHT, &pointer[0]);
          } else if (selectedItem == 1) {
            undrawImageDMA(HEIGHT / 2 + 28, 70, POINTER_WIDTH, POINTER_HEIGHT, &gtsimTitle[0]);
            selectedItem = 0;
            drawImageDMA(HEIGHT / 2 + 13, 70, POINTER_WIDTH, POINTER_HEIGHT, &pointer[0]);
          }
        }
        break;

      case PLAY:
        nextState = gamePlay(currentButtons, previousButtons, enemies);
        state = (enum gba_state) nextState;
        //state = LOSE;
        break;

      case WIN:
        if (KEY_JUST_PRESSED(BUTTON_B, currentButtons, previousButtons)) {
          state = LEADERBOARD;
          drawFullScreenImageDMA(leaderboard);
          drawScores();
          selectedItem = 0;
        }
        // state = ?
        break;
      case LEADERBOARD:
        if (KEY_JUST_PRESSED(BUTTON_L, currentButtons, previousButtons)) {
          if (KEY_DOWN(BUTTON_R, currentButtons)) {
            state = WIN;
            drawFullScreenImageDMA(win);
          }
        }
        if (KEY_JUST_PRESSED(BUTTON_B, currentButtons, previousButtons)) {
          drawTitleScreen();
          state = START;
        }
        break;
      case PLAYER_SELECT:
        if (KEY_JUST_PRESSED(BUTTON_LEFT, currentButtons, previousButtons) && (selectedPlayer > 0)) {
           selectedPlayer--;
           drawPSelectBox(selectedPlayer);
        }
        
        if (KEY_JUST_PRESSED(BUTTON_RIGHT, currentButtons, previousButtons) && (selectedPlayer < 2)) {
          selectedPlayer++;
          drawPSelectBox(selectedPlayer);
        }

        if (KEY_JUST_PRESSED(BUTTON_B, currentButtons, previousButtons)) {
          drawTitleScreen();
          state = START;
        }
        if (KEY_JUST_PRESSED(BUTTON_A, currentButtons, previousButtons)) {
          switch (selectedPlayer) {
            case 0:
              playerImgL = &buzzL[0];
              playerImgR = &buzzR[0];
              playerImg = playerImgL;
              break;

            case 1:
              playerImgL = &t[0];
              playerImgR = &t[0];
              playerImg = playerImgL;
              break;

            case 2:
              playerImgL = &pizzaL[0];
              playerImgR = &pizzaR[0];
              playerImg = playerImgL;
              break;
          }
          state = PLAY;
          drawFullScreenImageDMA(&background[0]);
        }

        break;
      case LOSE:
          drawFullScreenImageDMA(&pictureOfMonkEB[0]);
          int frames = 0;
          while (frames < 180) { // every ~1.5 seconds alternate color
            waitForVBlank();
            frames++;
          }
          if (KEY_DOWN(BUTTON_START, currentButtons)) {
            drawTitleScreen();
            state = START;
            break;
          }
          frames = 0;
          drawFullScreenImageDMA(&pictureOfMonkEO[0]);
          while (frames < 180) { // every ~1.5 seconds alternate color
            waitForVBlank();
            frames++;
          }
          
       
        // state = ?
        if (KEY_DOWN(BUTTON_START, currentButtons)) {
          drawTitleScreen();
          state = START;
        }
        break;

        
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  UNUSED(previousButtons); // You can remove this once previousButtons is used

  return 0;
}

int gamePlay(u32 currButtons, u32 oldButtons, enemy *enemies[]) {
    char playerTime[15];
    
    if ((vBlankCounter % 60) == 0) {
      currPlayerTime++;
    }
    waitForVBlank();
    sprintf(playerTime, "Time: %d", currPlayerTime);
    undrawImageDMA(150, 0, 50, 10, background);
    drawString(150, 0, playerTime, RED);
    undrawImageDMA(playerY, playerX, BUZZ_HEIGHT, BUZZ_HEIGHT, background);

    if (KEY_DOWN(BUTTON_L, currButtons)) {
      //move left
      playerImg = playerImgL;
      if (playerVX > 0) {
        playerVX = 0;
      }
      if (playerVX >= -3) {
        playerVX -= 1;
      }

      if ((playerX + playerVX < (WIDTH - BUZZ_HEIGHT)) & (playerX + playerVX > 0)) {
        playerX += playerVX;
      }
    } 
    
    if (KEY_DOWN(BUTTON_R, currButtons)) {
      //move right
      playerImg = playerImgR;
      if (playerVX < 0) {
        playerVX = 0;
      }
      if (playerVX <= 3) {
        playerVX += 1;
      }
      if ((playerX + playerVX < (WIDTH - BUZZ_HEIGHT)) & (playerX + playerVX > 0)) {
        playerX += playerVX;
      }
    }


    if (KEY_JUST_PRESSED(BUTTON_A, currButtons, oldButtons) && playerVY >= 0) {
      //flap wings
      playerVY -= 15;
    } else if ((playerVY < 5) & (playerY < HEIGHT - BUZZ_HEIGHT)) {
      playerVY += 1;
    } else if (playerY > HEIGHT - BUZZ_HEIGHT) {
      playerVY = 0;
    }

    if ((playerY > 0) & (playerY + playerVY > 0) & (playerY + playerVY < HEIGHT - BUZZ_HEIGHT)) {
      playerY += playerVY;
    }else if (playerY > HEIGHT) {
       playerY = 0;
    } // modify player's Y movement
    
    drawImageDMA(playerY, playerX, BUZZ_HEIGHT, BUZZ_HEIGHT, playerImg);

    
    //move enemies
    waitForVBlank();
    size_t enemyIndex = 0;

    while (enemies[enemyIndex] != NULL) {
      enemy *currEnemy = enemies[enemyIndex];

      undrawImageDMA(currEnemy->Y, currEnemy->X, currEnemy->width, currEnemy->height, &background[0]);

      //check for collision with player
      if ((currEnemy->Y + currEnemy->height > playerY) & (currEnemy->Y < playerY + BUZZ_HEIGHT)) { //vertical colision
        if ((currEnemy->X + currEnemy->width > playerX) & (currEnemy->X < playerX + BUZZ_HEIGHT)) {
          if ((selectedPlayer == 0) & (currPlayerTime > player0BestTime)) {
            player0BestTime = currPlayerTime;
            currPlayerTime = 0;
          }
          if ((selectedPlayer == 1) & (currPlayerTime > player1BestTime)) {
            player1BestTime = currPlayerTime;
            currPlayerTime = 0;
          }
          if ((selectedPlayer == 2) & (currPlayerTime > player2BestTime)) {
            player2BestTime = currPlayerTime;
            currPlayerTime = 0;
          }
          return LOSE;
        }
      }

      //check for bounce and make it bounce

      if (currEnemy->Y + currEnemy->VY >= HEIGHT - currEnemy->height - 10|| currEnemy->Y + currEnemy->VY <= 0) {
        (*currEnemy).VY *= -1;
      }
      
      if (currEnemy->X + currEnemy->VX >= WIDTH - currEnemy->width || currEnemy->X + currEnemy->VX <= 0) {
        (*currEnemy).VX *= -1;
      }

      (*currEnemy).X += currEnemy->VX;

      (*currEnemy).Y += currEnemy->VY;

      drawImageDMA(currEnemy->Y, currEnemy->X, currEnemy->width, currEnemy->height, currEnemy->img);

      enemyIndex++;
    }


    return (int) PLAY;
}

void drawTitleScreen(void) {
  drawFullScreenImageDMA(&gtsimTitle[0]);
  drawString(HEIGHT / 2 + 15, 85, playString, BLACK);
  drawString(HEIGHT /2 + 30, 85, leaderboardString, BLACK);
  drawImageDMA(HEIGHT / 2 + 13, 70, POINTER_WIDTH, POINTER_HEIGHT, &pointer[0]);
  return;
}

void drawPSelectBox(int player) {
  int boxY = 68;
  int boxX = 0;
  undrawImageDMA(boxY - 2, 80, 80, 30, playerSelectScreen);
  switch (player) {
    case 0:
      boxX = 84;
      break;
    case 1:
      boxX = 108;
      break;
    case 2:
      boxX = 132;
      break;
  }
  int xDrawn = 0;
  int yDrawn = 0;

  while (xDrawn < 24) {
    setPixel(boxY, boxX + xDrawn, RED);
    setPixel(boxY + 23, boxX + xDrawn, RED);

    xDrawn++;
  }

  while (yDrawn < 24) {
    setPixel(boxY + yDrawn, boxX, RED);
    setPixel(boxY + yDrawn, boxX + 23, RED);

    yDrawn++;
  }
}

void drawScores(void) {
  char scoreString0[5];
  char scoreString1[5];
  char scoreString2[5];

  sprintf(scoreString0, "%d", player0BestTime);
  sprintf(scoreString1, "%d", player1BestTime);
  sprintf(scoreString2, "%d", player2BestTime);
  drawString(45, 115, scoreString0, BLACK);
  drawString(45 + 28, 115, scoreString1, BLACK);
  drawString(45 + 28 * 2, 115, scoreString2, BLACK);
}